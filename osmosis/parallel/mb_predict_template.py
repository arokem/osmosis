
# Lines above this one are auto-generated by the wrapper to provide as params:
# i
import time
import osmosis.multi_bvals as sfm_mb
import osmosis.predict_n as pn
import nibabel as nib
import os
import numpy as np

if __name__=="__main__":
    t1 = time.time()
    data_path = "/biac4/wandell/data/klchan13/100307/Diffusion/data"
    
    data_file = nib.load(os.path.join(data_path, "data.nii.gz"))
    wm_data_file = nib.load(os.path.join(data_path,"wm_mask_registered.nii.gz"))
    
    data = data_file.get_data()
    wm_data = wm_data_file.get_data()
    wm_idx = np.where(wm_data==1)
    
    bvals = np.loadtxt(os.path.join(data_path, "bvals"))
    bvecs = np.loadtxt(os.path.join(data_path, "bvecs"))
    
    low = i*50
    # Make sure not to go over the edge of the mask:
    high = np.min([(i+1) * 50, int(np.sum(wm_data))])
    
    # Preserve memory by getting rid of this data:
    del wm_data

    # Now set the mask:
    mask = np.zeros(wm_data_file.shape)
    mask[wm_idx[0][low:high], wm_idx[1][low:high], wm_idx[2][low:high]] = 1
    
    # Just want to grab the number of non b = 0 directions
    bval_list, b_inds, unique_b, rounded_bvals = sfm_mb.separate_bvals(bvals/1000)
    all_b_idx = np.squeeze(np.where(rounded_bvals != 0))
    
    all_actual = np.empty((high - low, len(all_b_idx)))
    all_predict = np.empty(all_actual.shape)
    bvals_actual = np.empty(all_actual.shape)
    bvals_predict = np.empty(all_actual.shape) 
    for mi in np.arange(np.sum(mask)-1):
        this_mask = np.zeros(mask.shape)
        # Put 2 voxels in at a time
        this_mask[np.where(mask)[0][mi:mi+2], np.where(mask)[1][mi:mi+2],
                                            np.where(mask)[2][mi:mi+2]] = 1
        # Predict 10% (n = 10)
        actual_all, vox_predict_all = pn.predict_n(data, bvals/1000, bvecs,
                                                   this_mask, 10, 0, "all")
        actual_bvals, vox_predict_bvals = pn.predict_n(data, bvals/1000, bvecs,
                                                 this_mask, 10, 0, "bvals")
        all_actual[mi] = actual_all
        all_predict[mi] = vox_predict_all
        bvals_actual[mi] = actual_bvals
        bvals_predict[mi] = vox_predict_bvals
        # Need the very last voxel of the mask too
        if mi == np.sum(mask)-1:
            actual_all, vox_predict_all = pn.predict_n(data, bvals/1000, bvecs,
                                                  this_mask, 10, 1, "all")
            actual_bvals, vox_predict_bvals = pn.predict_n(data, bvals/1000, bvecs,
                                                 this_mask, 10, 1, "bvals")
            all_actual[mi+1] = actual_all
            all_predict[mi+1] = vox_predict_all
            bvals_actual[mi+1] = actual_bvals
            bvals_predict[mi+1] = vox_predict_bvals
    
    aff = np.eye(4)
    nib.Nifti1Image(all_actual, aff).to_filename("all_actual%s.nii.gz"%(i))
    nib.Nifti1Image(all_predict, aff).to_filename("all_predict%s.nii.gz"%(i)) 
    nib.Nifti1Image(bvals_actual, aff).to_filename("bvals_actual%s.nii.gz"%(i)) 
    nib.Nifti1Image(bvals_predict, aff).to_filename("bvals_predict%s.nii.gz"%(i)) 
    t2 = time.time()
    print "This program took %4.2f minutes to run."%((t2 - t1)/60.)