
# Lines above this one are auto-generated by the wrapper to provide as params:
# i, sid, fODF, im, data_path

"""
Template for finding the model parameters to the different diffusion models.
"""


import time
import osmosis.model.sparse_deconvolution as sfm
import osmosis.model.dti as dti
import osmosis.predict_n as pn
from osmosis.utils import separate_bvals
import osmosis.utils as ozu
import nibabel as nib
import os
import numpy as np

if __name__=="__main__":
    t1 = time.time()
    
    data_file = nib.load(os.path.join(data_path, "data.nii.gz"))
    wm_data_file = nib.load(os.path.join(data_path,"wm_mask_no_vent.nii.gz"))
    
    data = data_file.get_data()
    wm_data = np.round(wm_data_file.get_data()).astype(int)
    wm_idx = np.where(wm_data==1)
    
    bvals = np.loadtxt(os.path.join(data_path, "bvals"))
    bvecs = np.loadtxt(os.path.join(data_path, "bvecs"))
    
    low = i*2000
    # Make sure not to go over the edge of the mask:
    high = np.min([(i+1) * 2000, int(np.sum(wm_data))])
    
    # Preserve memory by getting rid of this data:
    del wm_data

    # Now set the mask:
    mask = np.zeros(wm_data_file.shape)
    mask[wm_idx[0][low:high], wm_idx[1][low:high], wm_idx[2][low:high]] = 1

    # Load the AD, RD values for this subject.
    ad_rd = np.loadtxt(os.path.join(data_path, "ad_rd_%s.txt"%sid))
    ad = {1000:ad_rd[0,0], 2000:ad_rd[0,1], 3000:ad_rd[0,2]}
    rd = {1000:ad_rd[1,0], 2000:ad_rd[1,1], 3000:ad_rd[1,2]}
    
    # Separate the b-values and find the indices to the data at every
    # b-value as well as the diffusion weighted data.
    bval_list, b_inds, unique_b, rounded_bvals = ozu.separate_bvals(bvals)
    _, b_inds_rm0, _, _ = ozu.separate_bvals(bvals, mode="remove0")
    all_b_idx = np.where(rounded_bvals != 0)
    
    # Set some shorthand notations for the different isotropic models
    # for file naming purposes.
    if im == "bi_exp_rs":
        shorthand_im = "be"
    elif im == "single_exp_rs":
        shorthand_im = "se"
    
    if fODF == "single":
        # Initialize the model object.
        mod = sfm.SparseDeconvolutionModelMultiB(data, bvecs, bvals,
                                                 mask=mask,
                                                 params_file="temp",
                                                 solver="nnls",
                                                 mean = "mean_model",
                                                 mean_mod_func=im,
                                                 axial_diffusivity=ad,
                                                 radial_diffusivity = rd)
        mp = mod.model_params[mod.mask] # Grab the model parameters.
    elif fODF == "multi":
        # Initialize a full model with data from all b-values to get the
        # parameters for the isotropic models
        full_mod = sfm.SparseDeconvolutionModelMultiB(data,
                                bvecs, bvals, mask = mask,
                                params_file="temp", solver="nnls",
                                mean="mean_model", mean_mod_func=im,
                                axial_diffusivity=ad,
                                radial_diffusivity=rd)
        sig_out, new_params = full_mod.fit_flat_rel_sig_avg

        mp = np.zeros((2000, len(all_b_idx[0])))
        for b_idx in np.arange(1, len(unique_b)):
            b_inds_w0 = np.concatenate((b_inds[0], b_inds[b_idx]))
            # Create a model object for the data from this b-value.
            this_mod = sfm.SparseDeconvolutionModelMultiB(data[...,b_inds_w0],
                                        bvecs[:,b_inds_w0], bvals[b_inds_w0],
                                        mask=mask, params_file="temp",
                                        solver="nnls", mean = "mean_model",
                                        mean_mod_func = im,
                                        axial_diffusivity=ad,
                                        radial_diffusivity=rd)
            # Replace the model parameters within the model object.
            this_mod.fit_flat_rel_sig_avg = [sig_out[:, b_inds_rm0[b_idx-1]], new_params]
            mp[:, b_inds_rm0[b_idx-1]] = this_mod.model_params[this_mod.mask]
    
    np.save(os.path.join(data_path, "model_params_%s_%s%s.npy"%(fODF,
                                               shorthand_im, i)), mp)
    
    t2 = time.time()
    print "This program took %4.2f minutes to run."%((t2 - t1)/60.)
