"""

This module is used to simulate DWI data from ODFs, or from fiber groups 


"""
import numpy as np

import tensor as ozt


# Global constants for this module:
AD = 1.5
RD = 0.5

# This converts b values from the data, so that it matches the units of ADC we
# use in the Stejskal/Tanner equation:
SCALE_FACTOR = 1000

class ODF(object):
    """
    This class represents a distribution of fiber orientations within a voxel
    
    """
    def __init__(self,
                 bvecs,
                 weights):

        self.bvecs = bvecs            
        self.weights = weights
        
        
class Voxel(object):
    """
    The representation of the measurement in a single voxel with some
    configuration of fibers crossing through it, represented by an ODF
    """
    def __init__(self,
                 bvecs,
                 bvals,
                 odf,
                 iso=False,
                 scaling_factor=SCALE_FACTOR,
                 axial_diffusivity=AD,
                 radial_diffusivity=RD):
        """
        The signal in a single voxel is computed from the convolution of a
        response function with the ODF
        
        Parameters
        ----------

        bvecs: 3 by n array
             unit vectors on the sphere.
        
        bvals: 1 by n array
             The measurement parameter defining where on the curve we measure
             the exponential decay of the signal

        odf: an ODF class instance
            The representation of the orientation distribution function. Note
            that this class also has bvecs, but these bvecs don't have to be
            the same bvecs as the ones of this class. bvecs In this class refer
            to measurement directions, while the bvecs in the ODF class refer
            to directions of fibers within the voxel (not necessarily the
            same...) 

        iso : float (optional)
            Whether and how much of an isotropic component to add to the
            signal. Default: False - no isotropic component
            
        scaling_factor: float (optional)
            To get the right units on the ADC, sometimes the b value needs to
            be scaled. Typically, divided by 1000 (default).

        axial_diffusivity, radial_diffusivity: float
            These parameters
            
        """

        self.bvecs = bvecs
        self.bvals = bvals/scaling_factor
        self.odf = odf
        
        # We assume that the response function is a cigar shaped tensor:
        self.Q = np.array([[axial_diffusivity, 0, 0],
                           [0, radial_diffusivity, 0],
                           [0, 0, radial_diffusivity]])
        self.response_function = ozt.Tensor(self.Q, self.bvecs, self.bvals)
        self.iso = iso

    def signal(self, S0=1):
        """
        The signal generated by the ODF in each bvec direction
        """
        # Initialize to zero:
        signal = np.zeros(self.bvecs.shape[-1])

        # Decompose the response function to its eigen-decomposition:
        evals, evecs = self.response_function.decompose
        # We generate the signal for each one of the fibers in the ODF: 
        for odf_idx, odf_vec in enumerate(self.odf.bvecs):
            this_response = ozt.rotate_to_vector(odf_vec,
                                                 evals,
                                                 evecs,
                                                 self.bvecs,
                                                 self.bvals)

            this_signal = (self.odf.weights[odf_idx] *
                          this_response.predicted_signal(S0))
            signal += this_signal
            
        if self.iso:
            # The iso component has the diffusivity of the tensor:
            md = np.mean(np.diag(self.Q))
            iso_signal = self.iso * ozt.stejskal_tanner(S0, self.bvals, md) 
            signal += iso_signal
            signal /=  np.sum(np.hstack([self.odf.weights, self.iso]))
        else:
            signal /=  np.sum(self.odf.weights)
            
        return signal

    def adc(self):
        """

        The ADC in each bvec direction, given the ODF

        """
        
        # Initialize to zero:
        adc = np.zeros(self.bvecs.shape[-1])

        # Decompose the response function to its eigen-decomposition:
        evals, evecs = self.response_function.decompose
        # We generate the signal for each one of the fibers in the ODF: 
        for odf_idx, odf_vec in enumerate(self.odf.bvecs):
            this_response = ozt.rotate_to_vector(odf_vec,
                                                 evals,
                                                 evecs,
                                                 self.bvecs,
                                                 self.bvals)
            this_adc = self.odf.weights[odf_idx] * this_response.ADC
            adc += this_adc

        return adc / np.sum(self.odf.weights)



class Volume(object):
    """
    A representation of an entire volume of data, can represent fibers passing
    through this location, or a collection of voxels with data
    """
    def __init__(self):
        raise NotImplementedError



def signal_1d(theta, b, fiber_weights, d_para, d_ortho, phi, iso_weights,
              d_iso):  
    """ 
    Simulate a 1-D diffusion signal 

    Parameters
    ----------
    theta : float or 1d array 
        The direction or directions of measurement
    
    b : float
        The b value of measurement 
    
    fiber_weights : float or 1d array
        The weight or weights on fiber components
    
    d_para : float or 1d array
        The axial diffusivity of fiber components 
        
    d_ortho : float or 1d array
        The radial diffusivity of fiber components 
    
    phi : float or 1d array
        Direction or directions of fiber components
    
    iso_weights: float or 1d array
        Weights on isotropic components
    
    d_iso : float or 1d array
        The diffusivity of isotropic components


    Notes
    -----
    This is based on equations in Dell'acqua et al.(2010).

    Under the assumption of slow exchange between fiber compartments in the
    voxel, The normalized signal $S(\theta, b) = \frac{S_b(\theta)}{S_0}$ is
    modeled as:

    .. math::
    
         S(\theta,b) = \sum_{i=1}^{m}{f_i e^{-b (\lambda_i cos^2(\theta-\phi_i) + \beta_i sin^2(\theta-\phi_i)}} + \sum_{j=1}^{n}{f_j e ^{-b\beta_j}}
                                        
    Where the left side of the equation represents the fiber contributions and
    the right side represents contributions from isotropic components. Each
    $\phi_i$ is the direction of a distinct fiber population, $\lambda_i$ and
    $\beta_i$ represent the axial and radial diffusivity of each fiber response
    function and $f_i$ represents the weight on that fiber population.  

    This can be re-written more compactly as: 

    .. math::

     S(\theta,b) = \sum_{i=1}^{m}{c_i e^{-b\alpha_i cos(\theta - \phi_i)}} + \sum_{j=1}^{q}{c_j}
 
    Where $\alpha_i = \lambda_i - \beta_i$ and $c_i = f_i e^{-b\beta_i}$

    """
    # Let's deal with the fiber signal first: 
    # Make it iterable if it isn't: 
    if type(fiber_weights) is float or type(fiber_weights) is int:  
        fiber_weights=[fiber_weights]

    if type(d_para) is float:
        d_para = [d_para] * len(fiber_weights)
    if type(d_ortho) is float:
        d_ortho = [d_ortho] * len(fiber_weights)

    if type(phi) is float or type(phi) is int:
        phi = [phi] * len(fiber_weights)
        
    sig = np.zeros(len(theta))
    
    for i in range(len(fiber_weights)):
        ang_diff = theta - phi[i]
        D = d_para[i] * np.cos(ang_diff)**2 + d_ortho[i] * np.sin(ang_diff)**2
        sig+=fiber_weights[i] * np.exp(-b * D)

    # Now we can deal with the isotropic signal:
    if type(iso_weights) is float or type(iso_weights) is int:  
        iso_weights=[iso_weights] 

    if type(d_iso) is float or type(d_iso) is int:
        d_iso = [d_iso] * len(iso_weights)
        
    for i in range(len(iso_weights)):
        sig += iso_weights[i] * np.exp(-b * d_iso[i])

    return sig

def tensor_1d(theta, b, ad, rd, phi, fiber_weight):
    """
    An analogue of a tensor in 1D

    
    """

    signal_1d(theta, b, fiber_weight, ad, rd, phi, iso_weights, d_iso)
